// Program to write in the EERPROM on the CryptoCape

#include <Wire.h>
#include <avr/pgmspace.h>

byte eeprom_addr = 0x57;
unsigned long crc = 0;
unsigned long crc_check = 0;
int led = 13;

static uint8_t eeprom_data[] = 
{
    0xaa, 0x55, 0x33, 0xee, 0x41, 0x31, 0x42, 0x42, 0x2d, 0x42, 0x4f,
    0x4e, 0x45, 0x2d, 0x43, 0x52, 0x59, 0x50, 0x54, 0x4f, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x41, 0x30, 0x53, 0x70,
    0x61, 0x72, 0x6b, 0x46, 0x75, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x42, 0x42, 0x2d, 0x42, 0x4f, 0x4e, 0x45, 0x2d,
    0x43, 0x52, 0x59, 0x50, 0x54, 0x4f, 0x00, 0x00, 0x00, 0x11, 0x32,
    0x30, 0x31, 0x34, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x73, 0xe0, 0x73,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xa0, 0x26, 0xc0, 0x06, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xa0, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xc0, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x47, 0x50, 0x47, 0x20, 0x46, 0x69, 0x6e, 0x67, 0x65,
    0x72, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x3a, 0x20, 0x30, 0x78, 0x42,
    0x35, 0x39, 0x31, 0x39, 0x42, 0x31, 0x41, 0x43, 0x37, 0x31, 0x33,
    0x35, 0x39, 0x30, 0x35, 0x46, 0x34, 0x36, 0x36, 0x39, 0x43, 0x38,
    0x34, 0x37, 0x42, 0x46, 0x41, 0x35, 0x30, 0x33, 0x31, 0x42, 0x44,
    0x32, 0x45, 0x44, 0x45, 0x41, 0x36, 0x0A
};

static PROGMEM prog_uint32_t crc_table[16] = {
    0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
    0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
    0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
};

unsigned long crc_update(unsigned long crc, byte data)
{
    byte tbl_idx;
    tbl_idx = crc ^ (data >> (0 * 4));
    crc = pgm_read_dword_near(crc_table + (tbl_idx & 0x0f)) ^ (crc >> 4);
    tbl_idx = crc ^ (data >> (1 * 4));
    crc = pgm_read_dword_near(crc_table + (tbl_idx & 0x0f)) ^ (crc >> 4);
    return crc;
}

void I2CEEPROM_Write( unsigned int address, byte data )
{
  Wire.beginTransmission(eeprom_addr);
  Wire.write((int)highByte(address) );
  Wire.write((int)lowByte(address) );
  Wire.write(data);
  Wire.endTransmission();
  delay(5); // wait for the I2C EEPROM to complete the write cycle
}

byte I2CEEPROM_Read(unsigned int address )
{
  byte data;
  Wire.beginTransmission(eeprom_addr);
  Wire.write((int)highByte(address) );
  Wire.write((int)lowByte(address) );
  Wire.endTransmission(false);
  Wire.requestFrom(eeprom_addr,(byte)1);
  while(Wire.available() == 0) // wait for data
    ;
  data = Wire.read();
  return data;
}
  



void setup()
{
  pinMode(led, OUTPUT);
  Serial.begin (9600);
  
  Wire.begin(); // join i2c bus (address optional for master)
 
  // Write the Data
  int x = 0;
  
  // Write the data out to the EEPROM
  for (x = 0; x < sizeof(eeprom_data); x++)
  {
    I2CEEPROM_Write (x, eeprom_data[x] );
  }

  
  // Calculate a CRC on the original data
  for (x = 0; x < sizeof(eeprom_data); x++)
  {
    crc = crc_update (crc, eeprom_data[x]);
  }
    
  //Delay to see a clean break on a logic analyzer
  delay(10);
  
  //Read back each byte from the EEPROM and calculate a CRC on that
 for (x = 0; x < sizeof(eeprom_data); x++)
 {
   byte b = I2CEEPROM_Read (x);
   crc_check = crc_update (crc_check, b);
 }
  
}



void loop()
{
  // The CRC on the original data should match the crc from the read back data
  if (crc == crc_check)
    {
        digitalWrite(led, HIGH);
        delay(1000);
        digitalWrite(led, LOW);
        delay(1000);
    }
  else
    {
        digitalWrite(led, HIGH);
        delay(200);
        digitalWrite(led, LOW);
        delay(200);
        digitalWrite(led, HIGH);
        delay(200);
        digitalWrite(led, LOW);
        delay(1000);
    }
   
}
